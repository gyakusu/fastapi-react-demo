================================================================================
チケットID: 001
タイトル: HTTPリクエスト/レスポンス可視化機能の追加
作成日: 2025-12-26
================================================================================

【1. 背景・目的】

本リポジトリは教育用のFastAPI + Reactデモアプリケーションである。
学習者がAPIの動作を理解するため、実際に送受信されているHTTPリクエストと
レスポンスをリアルタイムで可視化する機能が必要である。

通常、開発者ツールのNetworkタブで確認するような情報を、アプリケーション
画面上で直接表示することで、初学者にもわかりやすく教育的な価値を高める。


【2. 要求仕様】

2.1 機能要件

(1) HTTPリクエスト情報の記録と表示
    - HTTPメソッド（GET, POST, PUT, DELETE等）
    - リクエストURL（エンドポイント）
    - リクエストヘッダー（主要なもの: Content-Type, Authorization等）
    - リクエストボディ（JSON形式の場合は整形して表示）
    - 送信日時（タイムスタンプ）

(2) HTTPレスポンス情報の記録と表示
    - ステータスコード（200, 201, 400, 404, 500等）
    - ステータスコードに応じた色分け表示
      * 2xx系: 緑色（成功）
      * 4xx系: 黄色（クライアントエラー）
      * 5xx系: 赤色（サーバーエラー）
    - レスポンスボディ（JSON形式の場合は整形して表示）
    - 処理時間（リクエスト送信からレスポンス受信までの時間）

(3) ログの表示順序
    - 新しいリクエストが常に最上部に追加される
    - Twitter/X のタイムラインのような逆時系列表示
    - スクロール可能なリスト形式

(4) ログの操作
    - ログのクリア機能（全削除ボタン）
    - 個別ログの展開/折りたたみ機能（詳細を表示/非表示）
    - ログ件数の制限（例: 最新50件まで保持）

2.2 非機能要件

(1) パフォーマンス
    - リクエスト/レスポンスの記録がアプリケーションの動作を阻害しない
    - 大量のログが蓄積してもUIが重くならない

(2) ユーザビリティ
    - Material-UIを使用した美麗で見やすいデザイン
    - モバイル環境でも閲覧可能なレスポンシブ対応
    - JSONデータの整形表示（シンタックスハイライトは任意）

(3) 保守性
    - ログ記録ロジックと表示ロジックの分離
    - 既存のコードへの影響を最小限に抑える


【3. 画面仕様】

3.1 レイアウト

画面を2つの領域に分割する案を検討する:

案A: 左右分割レイアウト
    左側: 既存のデモフォーム
    右側: HTTPログ表示エリア

案B: 上下分割レイアウト
    上部: 既存のデモフォーム
    下部: HTTPログ表示エリア

案C: タブ切り替えレイアウト
    タブ1: 既存のデモフォーム
    タブ2: HTTPログ表示エリア

推奨: 案Bの上下分割レイアウト（画面幅に依存しない、見やすい）

3.2 HTTPログカードの表示内容（1件あたり）

各ログは折りたたみ可能なカード形式で表示する:

[折りたたみ時]
+------------------------------------------------------------------+
| [GET] /todos                                          200 OK     |
| 14:32:15  処理時間: 125ms                                        |
+------------------------------------------------------------------+

[展開時]
+------------------------------------------------------------------+
| [POST] /todos                                         201 Created|
| 14:35:22  処理時間: 89ms                              [折りたたむ]|
|------------------------------------------------------------------|
| Request:                                                         |
|   URL: http://localhost:8000/todos                               |
|   Headers:                                                       |
|     Content-Type: application/json                               |
|   Body:                                                          |
|     {                                                            |
|       "title": "新しいタスク",                                   |
|       "description": "説明文",                                   |
|       "completed": false                                         |
|     }                                                            |
|------------------------------------------------------------------|
| Response:                                                        |
|   Status: 201 Created                                            |
|   Body:                                                          |
|     {                                                            |
|       "id": 1,                                                   |
|       "title": "新しいタスク",                                   |
|       "description": "説明文",                                   |
|       "completed": false                                         |
|     }                                                            |
+------------------------------------------------------------------+


【4. 技術実装案】

4.1 案1: カスタムfetchフック + Context API

構成:
  - src/hooks/useHttpLogger.ts を作成
  - src/contexts/HttpLogContext.tsx を作成（Context API）
  - src/components/HttpLogViewer.tsx を作成（ログ表示）
  - fetch APIをラップしたカスタムフック useFetchWithLogging を提供

メリット:
  - 既存のfetch呼び出しを置き換えやすい
  - グローバルな状態管理が可能
  - Reactの標準的なパターン

デメリット:
  - 既存のコードを修正する箇所が多い
  - Contextの設計が必要

4.2 案2: Fetch APIのインターセプター + useState

構成:
  - src/utils/fetchInterceptor.ts を作成
  - グローバルなfetch関数をラップしてログを記録
  - App.tsxでログの状態管理とHttpLogViewerコンポーネント配置

メリット:
  - 既存のfetch呼び出しを変更不要
  - シンプルな実装

デメリット:
  - グローバルfetchのラップは副作用が大きい
  - テストが困難になる可能性

4.3 案3: カスタムhook + ローカル状態管理（推奨）

構成:
  - src/hooks/useFetch.ts を作成（fetch + ログ記録を統合）
  - src/components/HttpLogViewer.tsx を作成
  - App.tsx内でログ配列をuseStateで管理
  - DemoForm.tsxで useFetch フックを使用

メリット:
  - シンプルで理解しやすい
  - 既存コードへの影響が小さい
  - 関数型プログラミングの原則に従いやすい
  - immutable state patternを適用しやすい

デメリット:
  - 複数コンポーネント間でログ状態を共有する場合はprops drilling


【5. 対象ファイル】

新規作成ファイル:
  - frontend/src/hooks/useFetch.ts
  - frontend/src/components/HttpLogViewer.tsx
  - frontend/src/types/HttpLog.ts （型定義）

修正ファイル:
  - frontend/src/App.tsx （レイアウト調整、状態管理追加）
  - frontend/src/DemoForm.tsx （fetch → useFetch への置き換え）


【6. 制約条件】

(1) CLAUDE.mdの原則に従う
    - いきなりコーディングしない、まず案を3つ出す
    - 関数は有効行20行以内、ネスト2つまで
    - 積極的な関数型プログラミングの採用
    - immutable state patternの採用

(2) 既存機能への影響を最小化
    - 既存のAPIデモ機能は全て正常に動作し続けること
    - パフォーマンスの劣化がないこと

(3) 使用技術の統一
    - React + TypeScript
    - Material-UI（MUI）
    - 既存のプロジェクト構成に準拠


【7. 実装ステップ（案）】

ステップ1: 型定義の作成
  - HttpLog インターフェースを定義

ステップ2: カスタムフックの実装
  - useFetch フックを作成
  - リクエスト/レスポンスを記録する仕組み

ステップ3: ログ表示コンポーネントの実装
  - HttpLogViewer コンポーネントを作成
  - ログカードの展開/折りたたみ機能

ステップ4: App.tsx の修正
  - ログ状態の管理
  - レイアウトの調整（上下分割）

ステップ5: DemoForm.tsx の修正
  - fetch → useFetch への置き換え

ステップ6: テスト
  - 各APIエンドポイントでログが正しく記録されることを確認
  - UIの動作確認


【8. 補足事項】

(1) ログの永続化は行わない
    - ブラウザをリロードするとログはクリアされる
    - 教育用途のため、セッション内のみの保持で十分

(2) セキュリティ考慮事項
    - JWTトークンなどの機密情報は表示時にマスクする（任意実装）
    - パスワードフィールドは表示しない

(3) 将来的な拡張案
    - ログのフィルタリング機能（メソッド別、ステータスコード別）
    - ログのエクスポート機能（JSON形式でダウンロード）
    - WebSocketログの記録対応

================================================================================
